/*
Copyright (c) 2019-2020 Timur Gafarov.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module bindbc.wgpu;

import core.stdc.stdint;
import bindbc.loader;

enum WGPUSupport {
    noLibrary,
    badLibrary,
    wgpu051
}

alias WGPUNonZeroU64 = ulong;
alias WGPUOption_AdapterId = ulong;
alias WGPUOption_SurfaceId = ulong;
alias WGPUOption_TextureViewId = ulong;

/**
 * Bound uniform/storage buffer offsets must be aligned to this number.
 */
enum WGPUBIND_BUFFER_ALIGNMENT = 256;

enum WGPUCOPY_BYTES_PER_ROW_ALIGNMENT = 256;

enum WGPUDEFAULT_BIND_GROUPS = 4;

enum WGPUDESIRED_NUM_FRAMES = 3;

enum WGPUMAX_ANISOTROPY = 16;

enum WGPUMAX_COLOR_TARGETS = 4;

enum WGPUMAX_MIP_LEVELS = 16;

enum WGPUMAX_VERTEX_BUFFERS = 8;

enum WGPUAddressMode
{
    ClampToEdge = 0,
    Repeat = 1,
    MirrorRepeat = 2
}

enum WGPUBindingType
{
    UniformBuffer = 0,
    StorageBuffer = 1,
    ReadonlyStorageBuffer = 2,
    Sampler = 3,
    ComparisonSampler = 4,
    SampledTexture = 5,
    ReadonlyStorageTexture = 6,
    WriteonlyStorageTexture = 7
}

enum WGPUBlendFactor
{
    Zero = 0,
    One = 1,
    SrcColor = 2,
    OneMinusSrcColor = 3,
    SrcAlpha = 4,
    OneMinusSrcAlpha = 5,
    DstColor = 6,
    OneMinusDstColor = 7,
    DstAlpha = 8,
    OneMinusDstAlpha = 9,
    SrcAlphaSaturated = 10,
    BlendColor = 11,
    OneMinusBlendColor = 12
}

enum WGPUBlendOperation
{
    Add = 0,
    Subtract = 1,
    ReverseSubtract = 2,
    Min = 3,
    Max = 4
}

enum WGPUBufferMapAsyncStatus
{
    Success,
    Error,
    Unknown,
    ContextLost
}

enum WGPUCompareFunction
{
    Undefined = 0,
    Never = 1,
    Less = 2,
    Equal = 3,
    LessEqual = 4,
    Greater = 5,
    NotEqual = 6,
    GreaterEqual = 7,
    Always = 8
}

enum WGPUCullMode
{
    None = 0,
    Front = 1,
    Back = 2
}

enum WGPUFilterMode
{
    Nearest = 0,
    Linear = 1
}

enum WGPUFrontFace
{
    Ccw = 0,
    Cw = 1
}

enum WGPUIndexFormat
{
    Uint16 = 0,
    Uint32 = 1
}

enum WGPUInputStepMode
{
    Vertex = 0,
    Instance = 1
}

enum WGPULoadOp
{
    Clear = 0,
    Load = 1
}

enum WGPULogLevel
{
    Off = 0,
    Error = 1,
    Warn = 2,
    Info = 3,
    Debug = 4,
    Trace = 5
}

enum WGPUPowerPreference
{
    Default = 0,
    LowPower = 1,
    HighPerformance = 2
}

enum WGPUPresentMode
{
  /**
   * The presentation engine does **not** wait for a vertical blanking period and
   * the request is presented immediately. This is a low-latency presentation mode,
   * but visible tearing may be observed. Will fallback to `Fifo` if unavailable on the
   * selected  platform and backend. Not optimal for mobile.
   */
    Immediate = 0,
  /**
   * The presentation engine waits for the next vertical blanking period to update
   * the current image, but frames may be submitted without delay. This is a low-latency
   * presentation mode and visible tearing will **not** be observed. Will fallback to `Fifo`
   * if unavailable on the selected platform and backend. Not optimal for mobile.
   */
    Mailbox = 1,
  /**
   * The presentation engine waits for the next vertical blanking period to update
   * the current image. The framerate will be capped at the display refresh rate,
   * corresponding to the `VSync`. Tearing cannot be observed. Optimal for mobile.
   */
    Fifo = 2
}

enum WGPUPrimitiveTopology
{
    PointList = 0,
    LineList = 1,
    LineStrip = 2,
    TriangleList = 3,
    TriangleStrip = 4
}

enum WGPUStencilOperation
{
    Keep = 0,
    Zero = 1,
    Replace = 2,
    Invert = 3,
    IncrementClamp = 4,
    DecrementClamp = 5,
    IncrementWrap = 6,
    DecrementWrap = 7
}

enum WGPUStoreOp
{
    Clear = 0,
    Store = 1
}

enum WGPUSwapChainStatus {
    Good,
    Suboptimal,
    Timeout,
    Outdated,
    Lost,
    OutOfMemory
}

enum WGPUTextureAspect
{
    All,
    StencilOnly,
    DepthOnly
}

enum WGPUTextureComponentType
{
    Float,
    Sint,
    Uint
}

enum WGPUTextureDimension
{
    D1,
    D2,
    D3
}

enum WGPUTextureFormat
{
    R8Unorm = 0,
    R8Snorm = 1,
    R8Uint = 2,
    R8Sint = 3,
    R16Uint = 4,
    R16Sint = 5,
    R16Float = 6,
    Rg8Unorm = 7,
    Rg8Snorm = 8,
    Rg8Uint = 9,
    Rg8Sint = 10,
    R32Uint = 11,
    R32Sint = 12,
    R32Float = 13,
    Rg16Uint = 14,
    Rg16Sint = 15,
    Rg16Float = 16,
    Rgba8Unorm = 17,
    Rgba8UnormSrgb = 18,
    Rgba8Snorm = 19,
    Rgba8Uint = 20,
    Rgba8Sint = 21,
    Bgra8Unorm = 22,
    Bgra8UnormSrgb = 23,
    Rgb10a2Unorm = 24,
    Rg11b10Float = 25,
    Rg32Uint = 26,
    Rg32Sint = 27,
    Rg32Float = 28,
    Rgba16Uint = 29,
    Rgba16Sint = 30,
    Rgba16Float = 31,
    Rgba32Uint = 32,
    Rgba32Sint = 33,
    Rgba32Float = 34,
    Depth32Float = 35,
    Depth24Plus = 36,
    Depth24PlusStencil8 = 37
}

enum WGPUTextureViewDimension
{
    D1,
    D2,
    D2Array,
    Cube,
    CubeArray,
    D3
}

enum WGPUVertexFormat
{
    Uchar2 = 0,
    Uchar4 = 1,
    Char2 = 2,
    Char4 = 3,
    Uchar2Norm = 4,
    Uchar4Norm = 5,
    Char2Norm = 6,
    Char4Norm = 7,
    Ushort2 = 8,
    Ushort4 = 9,
    Short2 = 10,
    Short4 = 11,
    Ushort2Norm = 12,
    Ushort4Norm = 13,
    Short2Norm = 14,
    Short4Norm =15,
    Half2 = 16,
    Half4 = 17,
    Float = 18,
    Float2 = 19,
    Float3 = 20,
    Float4 = 21,
    Uint = 22,
    Uint2 = 23,
    Uint3 = 24,
    Uint4 = 25,
    Int = 26,
    Int2 = 27,
    Int3 = 28,
    Int4 = 29
}

alias WGPUId_Adapter_Dummy = WGPUNonZeroU64;
alias WGPUAdapterId = WGPUId_Adapter_Dummy;

alias WGPUId_Device_Dummy = WGPUNonZeroU64;
alias WGPUDeviceId = WGPUId_Device_Dummy;

alias WGPUExtensions = uint64_t;

enum
{
    WGPUExtensions_ANISOTROPIC_FILTERING = 65536,
    WGPUExtensions_ALL_WEBGPU = 65535,
    WGPUExtensions_ALL_UNSAFE = 18446462598732840960UL,
    WGPUExtensions_ALL_NATIVE = 18446744073709486080UL
}

struct WGPUCLimits
{
    uint max_bind_groups;
}

alias WGPUId_BindGroup_Dummy = WGPUNonZeroU64;
alias WGPUBindGroupId = WGPUId_BindGroup_Dummy;

alias WGPUId_BindGroupLayout_Dummy = WGPUNonZeroU64;
alias WGPUBindGroupLayoutId = WGPUId_BindGroupLayout_Dummy;

alias WGPUId_Buffer_Dummy = WGPUNonZeroU64;
alias WGPUBufferId = WGPUId_Buffer_Dummy;

alias WGPUBufferAddress = uint64_t;
alias WGPUBufferSize = uint64_t;

alias WGPUBufferMapCallback = extern(C) void function(WGPUBufferMapAsyncStatus status, ubyte* userdata);

alias WGPUId_CommandBuffer_Dummy = WGPUNonZeroU64;
alias WGPUCommandBufferId = WGPUId_CommandBuffer_Dummy;

alias WGPUCommandEncoderId = WGPUCommandBufferId;

struct WGPURawPass
{
    ubyte* data;
    ubyte* base;
    uintptr_t capacity;
    WGPUCommandEncoderId parent;
}

struct WGPUComputePassDescriptor
{
    uint todo;
}

alias WGPUId_TextureView_Dummy = WGPUNonZeroU64;
alias WGPUTextureViewId = WGPUId_TextureView_Dummy;

alias WGPUOptionRef_TextureViewId = WGPUTextureViewId; //const(WGPUTextureViewId)*;

struct WGPUColor
{
    double r;
    double g;
    double b;
    double a;
}

enum WGPUColor_TRANSPARENT = WGPUColor(0.0, 0.0, 0.0, 0.0);
enum WGPUColor_BLACK = WGPUColor(0.0, 0.0, 0.0, 1.0);
enum WGPUColor_WHITE = WGPUColor(1.0, 1.0, 1.0, 1.0);
enum WGPUColor_RED = WGPUColor(1.0, 0.0, 0.0, 1.0);
enum WGPUColor_GREEN = WGPUColor(0.0, 1.0, 0.0, 1.0);
enum WGPUColor_BLUE = WGPUColor(0.0, 0.0, 1.0, 1.0);

struct WGPURenderPassColorAttachmentDescriptorBase_TextureViewId
{
    WGPUTextureViewId attachment;
    WGPUOptionRef_TextureViewId resolve_target;
    WGPULoadOp load_op;
    WGPUStoreOp store_op;
    WGPUColor clear_color;
}

alias WGPURenderPassColorAttachmentDescriptor = WGPURenderPassColorAttachmentDescriptorBase_TextureViewId;


struct WGPURenderPassDepthStencilAttachmentDescriptorBase_TextureViewId
{
    WGPUTextureViewId attachment;
    WGPULoadOp depth_load_op;
    WGPUStoreOp depth_store_op;
    float clear_depth;
    ubyte depth_read_only;
    WGPULoadOp stencil_load_op;
    WGPUStoreOp stencil_store_op;
    uint clear_stencil;
    ubyte stencil_read_only;
}

alias WGPURenderPassDepthStencilAttachmentDescriptor = WGPURenderPassDepthStencilAttachmentDescriptorBase_TextureViewId;


struct WGPURenderPassDescriptor
{
    const WGPURenderPassColorAttachmentDescriptor* color_attachments;
    size_t color_attachments_length;
    const WGPURenderPassDepthStencilAttachmentDescriptor* depth_stencil_attachment;
}

struct WGPUTextureDataLayout
{
    WGPUBufferAddress offset;
    uint bytes_per_row;
    uint rows_per_image;
}

struct WGPUBufferCopyView
{
    WGPUBufferId buffer;
    WGPUTextureDataLayout layout;
}

alias WGPUId_Texture_Dummy = WGPUNonZeroU64;
alias WGPUTextureId = WGPUId_Texture_Dummy;

struct WGPUOrigin3d
{
    uint x;
    uint y;
    uint z;
}
enum WGPUOrigin3d_ZERO = WGPUOrigin3d(0, 0, 0);

struct WGPUTextureCopyView
{
    WGPUTextureId texture;
    uint mip_level;
    WGPUOrigin3d origin;
}

struct WGPUExtent3d
{
    uint width;
    uint height;
    uint depth;
}

struct WGPUCommandBufferDescriptor
{
    uint todo;
}

alias WGPUComputePassId = WGPURawPass*;

alias WGPURawString = const(char)*;

alias WGPUDynamicOffset = uint;

alias WGPUId_ComputePipeline_Dummy = WGPUNonZeroU64;
alias WGPUComputePipelineId = WGPUId_ComputePipeline_Dummy;

alias WGPUId_Surface = WGPUNonZeroU64;
alias WGPUSurfaceId = WGPUId_Surface;

struct WGPUBufferBinding
{
    WGPUBufferId buffer;
    WGPUBufferAddress offset;
    WGPUBufferSize size;
}

alias WGPUId_Sampler_Dummy = WGPUNonZeroU64;
alias WGPUSamplerId = WGPUId_Sampler_Dummy;

enum WGPUBindingResource_Tag
{
    Buffer,
    Sampler,
    TextureView
}

struct WGPUBindingResource_WGPUBuffer_Body
{
    WGPUBufferBinding _0;
}

struct WGPUBindingResource_WGPUSampler_Body
{
    WGPUSamplerId _0;
}

struct WGPUBindingResource_WGPUTextureView_Body
{
    WGPUTextureViewId _0;
}

struct WGPUBindingResource
{
    WGPUBindingResource_Tag tag;
    union
    {
        WGPUBindingResource_WGPUBuffer_Body buffer;
        WGPUBindingResource_WGPUSampler_Body sampler;
        WGPUBindingResource_WGPUTextureView_Body texture_view;
    };
}

struct WGPUBindGroupEntry
{
    uint binding;
    WGPUBindingResource resource;
}

struct WGPUBindGroupDescriptor
{
    const(char)* label;
    WGPUBindGroupLayoutId layout;
    const(WGPUBindGroupEntry)* entries;
    uintptr_t entries_length;
}

alias WGPUShaderStage = uint;

enum WGPUShaderStage_NONE = 0;
enum WGPUShaderStage_VERTEX = 1;
enum WGPUShaderStage_FRAGMENT = 2;
enum WGPUShaderStage_COMPUTE = 4;

struct WGPUBindGroupLayoutEntry
{
    uint binding;
    WGPUShaderStage visibility;
    WGPUBindingType ty;
    ubyte multisampled;
    ubyte has_dynamic_offset;
    WGPUTextureViewDimension view_dimension;
    WGPUTextureComponentType texture_component_type;
    WGPUTextureFormat storage_texture_format;
}

struct WGPUBindGroupLayoutDescriptor
{
    const(char)* label;
    const(WGPUBindGroupLayoutEntry)* entries;
    uintptr_t entries_length;
}

alias WGPULabel = const(char)*;

alias WGPUBufferUsage = uint;
enum WGPUBufferUsage_MAP_READ = 1;
enum WGPUBufferUsage_MAP_WRITE = 2;
enum WGPUBufferUsage_COPY_SRC = 4;
enum WGPUBufferUsage_COPY_DST = 8;
enum WGPUBufferUsage_INDEX = 16;
enum WGPUBufferUsage_VERTEX = 32;
enum WGPUBufferUsage_UNIFORM = 64;
enum WGPUBufferUsage_STORAGE = 128;
enum WGPUBufferUsage_INDIRECT = 256;

struct WGPUBufferDescriptor
{
    WGPULabel label;
    WGPUBufferAddress size;
    WGPUBufferUsage usage;
    ubyte mapped_at_creation;
}

struct WGPUCommandEncoderDescriptor
{
    const(char)* label;
}

alias WGPUId_PipelineLayout_Dummy = WGPUNonZeroU64;
alias WGPUPipelineLayoutId = WGPUId_PipelineLayout_Dummy;

alias WGPUId_ShaderModule_Dummy = WGPUNonZeroU64;
alias WGPUShaderModuleId = WGPUId_ShaderModule_Dummy;

struct WGPUProgrammableStageDescriptor
{
    WGPUShaderModuleId _module;
    WGPURawString entry_point;
}

struct WGPUComputePipelineDescriptor
{
    WGPUPipelineLayoutId layout;
    WGPUProgrammableStageDescriptor compute_stage;
}

struct WGPUPipelineLayoutDescriptor
{
    const(WGPUBindGroupLayoutId)* bind_group_layouts;
    uintptr_t bind_group_layouts_length;
}

alias WGPUId_RenderPipeline_Dummy = WGPUNonZeroU64;
alias WGPURenderPipelineId = WGPUId_RenderPipeline_Dummy;

struct WGPURasterizationStateDescriptor
{
    WGPUFrontFace front_face;
    WGPUCullMode cull_mode;
    int depth_bias;
    float depth_bias_slope_scale;
    float depth_bias_clamp;
}

struct WGPUBlendDescriptor
{
    WGPUBlendFactor src_factor;
    WGPUBlendFactor dst_factor;
    WGPUBlendOperation operation;
}

alias WGPUColorWrite = uint;
enum WGPUColorWrite_RED = 1;
enum WGPUColorWrite_GREEN = 2;
enum WGPUColorWrite_BLUE = 4;
enum WGPUColorWrite_ALPHA = 8;
enum WGPUColorWrite_COLOR = 7;
enum WGPUColorWrite_ALL = 15;

struct WGPUColorStateDescriptor
{
    WGPUTextureFormat format;
    WGPUBlendDescriptor alpha_blend;
    WGPUBlendDescriptor color_blend;
    WGPUColorWrite write_mask;
}

struct WGPUStencilStateFaceDescriptor
{
    WGPUCompareFunction compare;
    WGPUStencilOperation fail_op;
    WGPUStencilOperation depth_fail_op;
    WGPUStencilOperation pass_op;
}

struct WGPUDepthStencilStateDescriptor
{
    WGPUTextureFormat format;
    ubyte depth_write_enabled;
    WGPUCompareFunction depth_compare;
    WGPUStencilStateFaceDescriptor stencil_front;
    WGPUStencilStateFaceDescriptor stencil_back;
    uint stencil_read_mask;
    uint stencil_write_mask;
}

alias WGPUShaderLocation = uint;

struct WGPUVertexAttributeDescriptor
{
    WGPUBufferAddress offset;
    WGPUVertexFormat format;
    WGPUShaderLocation shader_location;
}

struct WGPUVertexBufferLayoutDescriptor
{
    WGPUBufferAddress array_stride;
    WGPUInputStepMode step_mode;
    const(WGPUVertexAttributeDescriptor)* attributes;
    uintptr_t attributes_length;
}

struct WGPUVertexStateDescriptor
{
    WGPUIndexFormat index_format;
    const(WGPUVertexBufferLayoutDescriptor)* vertex_buffers;
    uintptr_t vertex_buffers_length;
}

struct WGPURenderPipelineDescriptor
{
    WGPUPipelineLayoutId layout;
    WGPUProgrammableStageDescriptor vertex_stage;
    const(WGPUProgrammableStageDescriptor)* fragment_stage;
    WGPUPrimitiveTopology primitive_topology;
    const(WGPURasterizationStateDescriptor)* rasterization_state;
    const(WGPUColorStateDescriptor)* color_states;
    uintptr_t color_states_length;
    const(WGPUDepthStencilStateDescriptor)* depth_stencil_state;
    WGPUVertexStateDescriptor vertex_state;
    uint sample_count;
    uint sample_mask;
    ubyte alpha_to_coverage_enabled;
}

struct WGPUSamplerDescriptor
{
    const(char)* label;
    WGPUAddressMode address_mode_u;
    WGPUAddressMode address_mode_v;
    WGPUAddressMode address_mode_w;
    WGPUFilterMode mag_filter;
    WGPUFilterMode min_filter;
    WGPUFilterMode mipmap_filter;
    float lod_min_clamp;
    float lod_max_clamp;
    WGPUCompareFunction compare;
}

struct WGPUU32Array
{
    const(uint)* bytes;
    uintptr_t length;
}

struct WGPUShaderModuleDescriptor
{
    WGPUU32Array code;
}

alias WGPUId_SwapChain_Dummy = WGPUNonZeroU64;
alias WGPUSwapChainId = WGPUId_SwapChain_Dummy;

alias WGPUTextureUsage = uint;
enum WGPUTextureUsage_COPY_SRC = 1;
enum WGPUTextureUsage_COPY_DST = 2;
enum WGPUTextureUsage_SAMPLED = 4;
enum WGPUTextureUsage_STORAGE = 8;
enum WGPUTextureUsage_OUTPUT_ATTACHMENT = 16;

struct WGPUSwapChainDescriptor
{
    WGPUTextureUsage usage;
    WGPUTextureFormat format;
    uint width;
    uint height;
    WGPUPresentMode present_mode;
}

struct WGPUTextureDescriptor
{
    const(char)* label;
    WGPUExtent3d size;
    uint mip_level_count;
    uint sample_count;
    WGPUTextureDimension dimension;
    WGPUTextureFormat format;
    WGPUTextureUsage usage;
}

alias WGPUQueueId = WGPUDeviceId;

alias WGPURenderPassId = WGPURawPass*;

alias WGPUId_RenderBundle_Dummy = WGPUNonZeroU64;
alias WGPURenderBundleId = WGPUId_RenderBundle_Dummy;

struct WGPURequestAdapterOptions
{
    WGPUPowerPreference power_preference;
    WGPUOption_SurfaceId compatible_surface;
}

alias WGPUBackendBit = uint;

alias WGPURequestAdapterCallback = extern(C) void function(WGPUOption_AdapterId id, void* userdata);

alias WGPULogCallback = extern(C) void function(int level, const(char)* msg);

struct WGPUSwapChainOutput
{
    WGPUSwapChainStatus status;
    WGPUOption_TextureViewId view_id;
}

struct WGPUTextureViewDescriptor
{
    WGPULabel label;
    WGPUTextureFormat format;
    WGPUTextureViewDimension dimension;
    WGPUTextureAspect aspect;
    uint base_mip_level;
    uint level_count;
    uint base_array_layer;
    uint array_layer_count;
}

extern(C) @nogc nothrow
{
    alias da_wgpu_adapter_destroy = void function(WGPUAdapterId adapter_id);

    alias da_wgpu_adapter_request_device = WGPUDeviceId function(WGPUAdapterId adapter_id, 
                                                                 WGPUExtensions extensions,
                                                                 const(WGPUCLimits)* limits,
                                                                 const(char)* trace_path);
    
    alias da_wgpu_bind_group_destroy = void function(WGPUBindGroupId bind_group_id);
    
    alias da_wgpu_bind_group_layout_destroy = void function(WGPUBindGroupLayoutId bind_group_layout_id);
    
    alias da_wgpu_buffer_destroy = void function(WGPUBufferId buffer_id);
    
    alias da_wgpu_buffer_get_mapped_range = ubyte* function(WGPUBufferId buffer_id,
                                                            WGPUBufferAddress start,
                                                            WGPUBufferSize size);
    
    alias da_wgpu_buffer_map_read_async = void function(WGPUBufferId buffer_id,
                                                        WGPUBufferAddress start, 
                                                        WGPUBufferAddress size, 
                                                        WGPUBufferMapCallback callback, 
                                                        ubyte* userdata);
    
    alias da_wgpu_buffer_map_write_async = void function(WGPUBufferId buffer_id,
                                                         WGPUBufferAddress start,
                                                         WGPUBufferAddress size,
                                                         WGPUBufferMapCallback callback,
                                                         ubyte* userdata);
    
    alias da_wgpu_buffer_unmap = void function(WGPUBufferId buffer_id);
    
    alias da_wgpu_command_buffer_destroy = void function(WGPUCommandBufferId command_buffer_id);
    
    /**
     * # Safety
     *
     * This function is unsafe because improper use may lead to memory
     * problems. For example, a double-free may occur if the function is called
     * twice on the same raw pointer.
     */
    alias da_wgpu_command_encoder_begin_compute_pass = WGPURawPass* function(WGPUCommandEncoderId encoder_id, 
                                                                             const WGPUComputePassDescriptor* _desc);
    
    /**
     * # Safety
     *
     * This function is unsafe because improper use may lead to memory
     * problems. For example, a double-free may occur if the function is called
     * twice on the same raw pointer.
     */
    alias da_wgpu_command_encoder_begin_render_pass = WGPURawPass* function(WGPUCommandEncoderId encoder_id,
                                                                            const WGPURenderPassDescriptor* desc);
    
    alias da_wgpu_command_encoder_copy_buffer_to_buffer = void function(WGPUCommandEncoderId command_encoder_id,
                                                                        WGPUBufferId source,
                                                                        WGPUBufferAddress source_offset,
                                                                        WGPUBufferId destination,
                                                                        WGPUBufferAddress destination_offset,
                                                                        WGPUBufferAddress size);
    
    alias da_wgpu_command_encoder_copy_buffer_to_texture = void function(WGPUCommandEncoderId command_encoder_id,
                                                                         const(WGPUBufferCopyView)* source,
                                                                         const(WGPUTextureCopyView)* destination,
                                                                         WGPUExtent3d copy_size);
    
    alias da_wgpu_command_encoder_copy_texture_to_buffer = void function(WGPUCommandEncoderId command_encoder_id,
                                                                         const(WGPUTextureCopyView)* source,
                                                                         const(WGPUBufferCopyView)* destination,
                                                                         WGPUExtent3d copy_size);
    
    alias da_wgpu_command_encoder_copy_texture_to_texture = void function(WGPUCommandEncoderId command_encoder_id,
                                                                          const(WGPUTextureCopyView)* source,
                                                                          const(WGPUTextureCopyView)* destination,
                                                                          WGPUExtent3d copy_size);
    
    alias da_wgpu_command_encoder_destroy = void function(WGPUCommandEncoderId command_encoder_id);
    
    alias da_wgpu_command_encoder_finish = WGPUCommandBufferId function(WGPUCommandEncoderId encoder_id,
                                                                        const(WGPUCommandBufferDescriptor)* desc);
    
    alias da_wgpu_compute_pass_destroy = void function(WGPURawPass* pass);
    
    alias da_wgpu_compute_pass_dispatch = void function(WGPURawPass* pass, 
                                                        uint groups_x, 
                                                        uint groups_y, 
                                                        uint groups_z);
    
    alias da_wgpu_compute_pass_dispatch_indirect = void function(WGPURawPass* pass,
                                                                 WGPUBufferId buffer_id,
                                                                 WGPUBufferAddress offset);
    
    alias da_wgpu_compute_pass_end_pass = void function(WGPUComputePassId pass_id);
    
    alias da_wgpu_compute_pass_insert_debug_marker = void function(WGPURawPass* _pass, WGPURawString _label);
    
    alias da_wgpu_compute_pass_pop_debug_group = void function(WGPURawPass* _pass);
    
    alias da_wgpu_compute_pass_push_debug_group = void function(WGPURawPass* _pass, WGPURawString _label);
    
    /**
     * # Safety
     *
     * This function is unsafe as there is no guarantee that the given pointer is
     * valid for `offset_length` elements.
     */
    alias da_wgpu_compute_pass_set_bind_group = void function(WGPURawPass* pass,
                                                              uint index,
                                                              WGPUBindGroupId bind_group_id,
                                                              const(WGPUBufferAddress)* offsets,
                                                              size_t offsets_length);
    
    alias da_wgpu_compute_pass_set_pipeline = void function(WGPURawPass* pass, WGPUComputePipelineId pipeline_id);
    
    alias da_wgpu_create_surface_from_android = WGPUSurfaceId function(void* a_native_window);
    
    alias da_wgpu_create_surface_from_metal_layer = WGPUSurfaceId function(void* layer);
    
    alias da_wgpu_create_surface_from_wayland = WGPUSurfaceId function(void* surface, void* display);
    
    alias da_wgpu_create_surface_from_windows_hwnd = WGPUSurfaceId function(void* _hinstance, void* hwnd);
    
    alias da_wgpu_create_surface_from_xlib = WGPUSurfaceId function(const void** display, ulong window);
    
    alias da_wgpu_device_create_bind_group = WGPUBindGroupId function(WGPUDeviceId device_id, 
                                                                      const WGPUBindGroupDescriptor* desc);
    
    alias da_wgpu_device_create_bind_group_layout = WGPUBindGroupLayoutId function(WGPUDeviceId device_id, 
                                                                                   const WGPUBindGroupLayoutDescriptor* desc);
    
    alias da_wgpu_device_create_buffer = WGPUBufferId function(WGPUDeviceId device_id, const WGPUBufferDescriptor* desc);
    
    alias da_wgpu_device_create_command_encoder = WGPUCommandEncoderId function(WGPUDeviceId device_id,
                                                                                const(WGPUCommandEncoderDescriptor)* desc);
    
    alias da_wgpu_device_create_compute_pipeline = WGPUComputePipelineId function(WGPUDeviceId device_id,
                                                                                  const(WGPUComputePipelineDescriptor)* desc);
    
    alias da_wgpu_device_create_pipeline_layout = WGPUPipelineLayoutId function(WGPUDeviceId device_id,
                                                                                const(WGPUPipelineLayoutDescriptor)* desc);
    
    alias da_wgpu_device_create_render_pipeline = WGPURenderPipelineId function(WGPUDeviceId device_id,
                                                                                const(WGPURenderPipelineDescriptor)* desc);
    
    alias da_wgpu_device_create_sampler = WGPUSamplerId function(WGPUDeviceId device_id, const(WGPUSamplerDescriptor)* desc);
    
    alias da_wgpu_device_create_shader_module = WGPUShaderModuleId function(WGPUDeviceId device_id,
                                                                            const(WGPUShaderModuleDescriptor)* desc);
    
    alias da_wgpu_device_create_swap_chain = WGPUSwapChainId function(WGPUDeviceId device_id,
                                                                      WGPUSurfaceId surface_id,
                                                                      const(WGPUSwapChainDescriptor)* desc);

    alias da_wgpu_device_create_texture = WGPUTextureId function(WGPUDeviceId device_id, const(WGPUTextureDescriptor)* desc);

    alias da_wgpu_device_destroy = void function(WGPUDeviceId device_id);

    alias da_wgpu_device_get_default_queue = WGPUQueueId function(WGPUDeviceId device_id);
    
    alias da_wgpu_device_get_limits = void function(WGPUDeviceId _device_id, WGPUCLimits* limits);
    
    alias da_wgpu_device_poll = void function(WGPUDeviceId device_id, ubyte force_wait);
    
    /**
     * # Safety
     *
     * This function is unsafe as there is no guarantee that the given pointer is
     * valid for `command_buffers_length` elements.
     */
    alias da_wgpu_queue_submit = void function(WGPUQueueId queue_id,
                                               const WGPUCommandBufferId* command_buffers,
                                               uintptr_t command_buffers_length);
    
    /**
     * # Safety
     *
     * This function is unsafe as there is no guarantee that the given `data`
     * pointer is valid for `data_length` elements.
     */
    alias da_wgpu_queue_write_buffer = void function(WGPUQueueId queue_id,
                                                     WGPUBufferId buffer_id,
                                                     WGPUBufferAddress buffer_offset,
                                                     const(ubyte)* data,
                                                     uintptr_t data_length);
    
    /**
     * # Safety
     *
     * This function is unsafe as there is no guarantee that the given `data`
     * pointer is valid for `data_length` elements.
     */
    alias da_wgpu_queue_write_texture = void function(WGPUQueueId queue_id,
                                                      const(WGPUTextureCopyView)* texture,
                                                      const(ubyte)* data,
                                                      uintptr_t data_length,
                                                      const(WGPUTextureDataLayout)* data_layout,
                                                      const(WGPUExtent3d)* size);
    
    alias da_wgpu_render_pass_destroy = void function(WGPURawPass *pass);
    
    alias da_wgpu_render_pass_draw = void function(WGPURawPass *pass,
                                                   uint vertex_count,
                                                   uint instance_count,
                                                   uint first_vertex,
                                                   uint first_instance);
    
    alias da_wgpu_render_pass_draw_indexed = void function(WGPURawPass *pass,
                                                           uint index_count,
                                                           uint instance_count,
                                                           uint first_index,
                                                           int base_vertex,
                                                           uint first_instance);
    
    alias da_wgpu_render_pass_draw_indexed_indirect = void function(WGPURawPass *pass,
                                                                    WGPUBufferId buffer_id,
                                                                    WGPUBufferAddress offset);
    
    alias da_wgpu_render_pass_draw_indirect = void function(WGPURawPass *pass,
                                                            WGPUBufferId buffer_id,
                                                            WGPUBufferAddress offset);
    
    /**
     * # Safety
     *
     * This function is unsafe because improper use may lead to memory
     * problems. For example, a double-free may occur if the function is called
     * twice on the same raw pointer.
     */
    alias da_wgpu_render_pass_end_pass = void function(WGPURenderPassId pass_id);
    
    alias da_wgpu_render_pass_execute_bundles = void function(WGPURawPass *_pass,
                                                              const WGPURenderBundleId *_bundles,
                                                              uintptr_t _bundles_length);
    
    alias da_wgpu_render_pass_insert_debug_marker = void function(WGPURawPass *_pass, WGPURawString _label);
    
    alias da_wgpu_render_pass_pop_debug_group = void function(WGPURawPass *_pass);
    
    alias da_wgpu_render_pass_push_debug_group = void function(WGPURawPass *_pass, WGPURawString _label);
    
    /**
     * # Safety
     *
     * This function is unsafe as there is no guarantee that the given pointer is
     * valid for `offset_length` elements.
     */
    alias da_wgpu_render_pass_set_bind_group = void function(WGPURawPass* pass,
                                                             uint index,
                                                             WGPUBindGroupId bind_group_id,
                                                             const WGPUBufferAddress* offsets,
                                                             uintptr_t offsets_length);
    
    alias da_wgpu_render_pass_set_blend_color = void function(WGPURawPass* pass, const WGPUColor* color);
    
    alias da_wgpu_render_pass_set_index_buffer = void function(WGPURawPass* pass,
                                                               WGPUBufferId buffer_id,
                                                               WGPUBufferAddress offset,
                                                               WGPUBufferAddress size);
    
    alias da_wgpu_render_pass_set_pipeline = void function(WGPURawPass* pass, WGPURenderPipelineId pipeline_id);
    
    alias da_wgpu_render_pass_set_scissor_rect = void function(WGPURawPass *pass,
                                                               uint x,
                                                               uint y,
                                                               uint w,
                                                               uint h);
    
    alias da_wgpu_render_pass_set_stencil_reference = void function(WGPURawPass* pass, uint value);
    
    alias da_wgpu_render_pass_set_vertex_buffer = void function(WGPURawPass* pass,
                                                                uint slot,
                                                                WGPUBufferId buffer_id,
                                                                WGPUBufferAddress offset,
                                                                WGPUBufferAddress size);
    
    alias da_wgpu_render_pass_set_viewport = void function(WGPURawPass* pass,
                                                           float x,
                                                           float y,
                                                           float w,
                                                           float h,
                                                           float min_depth,
                                                           float max_depth);
    
    alias da_wgpu_render_pipeline_destroy = void function(WGPURenderPipelineId render_pipeline_id);
    
    /**
     * # Safety
     *
     * This function is unsafe as it calls an unsafe extern callback.
     */
    alias da_wgpu_request_adapter_async = void function(const WGPURequestAdapterOptions *desc, 
                                                        WGPUBackendBit mask, 
                                                        ubyte allow_unsafe,
                                                        WGPURequestAdapterCallback callback, 
                                                        void* userdata);

    alias da_wgpu_sampler_destroy = void function(WGPUSamplerId sampler_id);
    
    alias da_wgpu_set_log_callback = void function(WGPULogCallback callback);

    alias da_wgpu_set_log_level = int function(WGPULogLevel level);
    
    alias da_wgpu_shader_module_destroy = void function(WGPUShaderModuleId shader_module_id);

    alias da_wgpu_swap_chain_get_next_texture = WGPUSwapChainOutput function(WGPUSwapChainId swap_chain_id);
    
    alias da_wgpu_swap_chain_present = void function(WGPUSwapChainId swap_chain_id);
    
    alias da_wgpu_texture_create_view = WGPUTextureViewId function(WGPUTextureId texture_id, 
                                                                   const WGPUTextureViewDescriptor *desc);
    
    alias da_wgpu_texture_destroy = void function(WGPUTextureId texture_id);
    
    alias da_wgpu_texture_view_destroy = void function(WGPUTextureViewId texture_view_id);
}

__gshared
{
    da_wgpu_adapter_destroy wgpu_adapter_destroy;
    da_wgpu_adapter_request_device wgpu_adapter_request_device;
    da_wgpu_bind_group_destroy wgpu_bind_group_destroy;
    da_wgpu_bind_group_layout_destroy wgpu_bind_group_layout_destroy;
    da_wgpu_buffer_destroy wgpu_buffer_destroy;
    da_wgpu_buffer_get_mapped_range wgpu_buffer_get_mapped_range;
    da_wgpu_buffer_map_read_async wgpu_buffer_map_read_async;
    da_wgpu_buffer_map_write_async wgpu_buffer_map_write_async;
    da_wgpu_buffer_unmap wgpu_buffer_unmap;
    da_wgpu_command_buffer_destroy wgpu_command_buffer_destroy;
    da_wgpu_command_encoder_begin_compute_pass wgpu_command_encoder_begin_compute_pass;
    da_wgpu_command_encoder_begin_render_pass wgpu_command_encoder_begin_render_pass;
    da_wgpu_command_encoder_copy_buffer_to_buffer wgpu_command_encoder_copy_buffer_to_buffer;
    da_wgpu_command_encoder_copy_buffer_to_texture wgpu_command_encoder_copy_buffer_to_texture;
    da_wgpu_command_encoder_copy_texture_to_buffer wgpu_command_encoder_copy_texture_to_buffer;
    da_wgpu_command_encoder_copy_texture_to_texture wgpu_command_encoder_copy_texture_to_texture;
    da_wgpu_command_encoder_destroy wgpu_command_encoder_destroy;
    da_wgpu_command_encoder_finish wgpu_command_encoder_finish;
    da_wgpu_compute_pass_destroy wgpu_compute_pass_destroy;
    da_wgpu_compute_pass_dispatch wgpu_compute_pass_dispatch;
    da_wgpu_compute_pass_dispatch_indirect wgpu_compute_pass_dispatch_indirect;
    da_wgpu_compute_pass_end_pass wgpu_compute_pass_end_pass;
    da_wgpu_compute_pass_insert_debug_marker wgpu_compute_pass_insert_debug_marker;
    da_wgpu_compute_pass_pop_debug_group wgpu_compute_pass_pop_debug_group;
    da_wgpu_compute_pass_push_debug_group wgpu_compute_pass_push_debug_group;
    da_wgpu_compute_pass_set_bind_group wgpu_compute_pass_set_bind_group;
    da_wgpu_compute_pass_set_pipeline wgpu_compute_pass_set_pipeline;
    da_wgpu_create_surface_from_android wgpu_create_surface_from_android;
    da_wgpu_create_surface_from_metal_layer wgpu_create_surface_from_metal_layer;
    da_wgpu_create_surface_from_wayland wgpu_create_surface_from_wayland;
    da_wgpu_create_surface_from_windows_hwnd wgpu_create_surface_from_windows_hwnd;
    da_wgpu_create_surface_from_xlib wgpu_create_surface_from_xlib;
    da_wgpu_device_create_bind_group wgpu_device_create_bind_group;
    da_wgpu_device_create_bind_group_layout wgpu_device_create_bind_group_layout;
    da_wgpu_device_create_buffer wgpu_device_create_buffer;
    da_wgpu_device_create_command_encoder wgpu_device_create_command_encoder;
    da_wgpu_device_create_compute_pipeline wgpu_device_create_compute_pipeline;
    da_wgpu_device_create_pipeline_layout wgpu_device_create_pipeline_layout;
    da_wgpu_device_create_render_pipeline wgpu_device_create_render_pipeline;
    da_wgpu_device_create_sampler wgpu_device_create_sampler;
    da_wgpu_device_create_shader_module wgpu_device_create_shader_module;
    da_wgpu_device_create_swap_chain wgpu_device_create_swap_chain;
    da_wgpu_device_create_texture wgpu_device_create_texture;
    da_wgpu_device_destroy wgpu_device_destroy;
    da_wgpu_device_get_limits wgpu_device_get_limits;
    da_wgpu_device_get_default_queue wgpu_device_get_default_queue;
    da_wgpu_device_poll wgpu_device_poll;
    da_wgpu_queue_submit wgpu_queue_submit;
    da_wgpu_queue_write_buffer wgpu_queue_write_buffer;
    da_wgpu_queue_write_texture wgpu_queue_write_texture;
    da_wgpu_render_pass_destroy wgpu_render_pass_destroy;
    da_wgpu_render_pass_draw wgpu_render_pass_draw;
    da_wgpu_render_pass_draw_indexed wgpu_render_pass_draw_indexed;
    da_wgpu_render_pass_draw_indexed_indirect wgpu_render_pass_draw_indexed_indirect;
    da_wgpu_render_pass_draw_indirect wgpu_render_pass_draw_indirect;
    da_wgpu_render_pass_end_pass wgpu_render_pass_end_pass;
    da_wgpu_render_pass_execute_bundles wgpu_render_pass_execute_bundles;
    da_wgpu_render_pass_insert_debug_marker wgpu_render_pass_insert_debug_marker;
    da_wgpu_render_pass_pop_debug_group wgpu_render_pass_pop_debug_group;
    da_wgpu_render_pass_push_debug_group wgpu_render_pass_push_debug_group;
    da_wgpu_render_pass_set_bind_group wgpu_render_pass_set_bind_group;
    da_wgpu_render_pass_set_blend_color wgpu_render_pass_set_blend_color;
    da_wgpu_render_pass_set_index_buffer wgpu_render_pass_set_index_buffer;
    da_wgpu_render_pass_set_pipeline wgpu_render_pass_set_pipeline;
    da_wgpu_render_pass_set_scissor_rect wgpu_render_pass_set_scissor_rect;
    da_wgpu_render_pass_set_stencil_reference wgpu_render_pass_set_stencil_reference;
    da_wgpu_render_pass_set_vertex_buffer wgpu_render_pass_set_vertex_buffer;
    da_wgpu_render_pass_set_viewport wgpu_render_pass_set_viewport;
    da_wgpu_render_pipeline_destroy wgpu_render_pipeline_destroy;
    da_wgpu_request_adapter_async wgpu_request_adapter_async;
    da_wgpu_sampler_destroy wgpu_sampler_destroy;
    da_wgpu_set_log_callback wgpu_set_log_callback;
    da_wgpu_set_log_level wgpu_set_log_level;
    da_wgpu_shader_module_destroy wgpu_shader_module_destroy;
    da_wgpu_swap_chain_get_next_texture wgpu_swap_chain_get_next_texture;
    da_wgpu_swap_chain_present wgpu_swap_chain_present;
    da_wgpu_texture_create_view wgpu_texture_create_view;
    da_wgpu_texture_destroy wgpu_texture_destroy;
    da_wgpu_texture_view_destroy wgpu_texture_view_destroy;
}

private
{
    SharedLib lib;
    WGPUSupport loadedVersion;
}

void unloadWGPU()
{
    if (lib != invalidHandle)
    {
        lib.unload();
    }
}

WGPUSupport loadedWGPUVersion() { return loadedVersion; }
bool isWGPULoaded() { return lib != invalidHandle; }

WGPUSupport loadWGPU()
{
    version(Windows)
    {
        const(char)[][1] libNames =
        [
            "wgpu_native.dll"
        ];
    }
    else version(OSX)
    {
        const(char)[][1] libNames =
        [
            "wgpu_native.dylib"
        ];
    }
    else version(Posix)
    {
        const(char)[][2] libNames =
        [
            "libwgpu_native.so",
            "/usr/local/lib/libwgpu_native.so",
        ];
    }
    else static assert(0, "wgpu_native is not yet supported on this platform.");

    WGPUSupport ret;
    foreach(name; libNames)
    {
        ret = loadWGPU(name.ptr);
        if (ret != WGPUSupport.noLibrary)
            break;
    }
    return ret;
}

WGPUSupport loadWGPU(const(char)* libName)
{
    lib = load(libName);
    if(lib == invalidHandle)
    {
        return WGPUSupport.noLibrary;
    }

    auto errCount = errorCount();
    loadedVersion = WGPUSupport.badLibrary;

    lib.bindSymbol(cast(void**)&wgpu_adapter_destroy, "wgpu_adapter_destroy");
    lib.bindSymbol(cast(void**)&wgpu_adapter_request_device, "wgpu_adapter_request_device");
    lib.bindSymbol(cast(void**)&wgpu_bind_group_destroy, "wgpu_bind_group_destroy");
    lib.bindSymbol(cast(void**)&wgpu_bind_group_layout_destroy, "wgpu_bind_group_layout_destroy");
    lib.bindSymbol(cast(void**)&wgpu_buffer_destroy, "wgpu_buffer_destroy");
    lib.bindSymbol(cast(void**)&wgpu_buffer_get_mapped_range, "wgpu_buffer_get_mapped_range");
    lib.bindSymbol(cast(void**)&wgpu_buffer_map_read_async, "wgpu_buffer_map_read_async");
    lib.bindSymbol(cast(void**)&wgpu_buffer_map_write_async, "wgpu_buffer_map_write_async");
    lib.bindSymbol(cast(void**)&wgpu_buffer_unmap, "wgpu_buffer_unmap");
    lib.bindSymbol(cast(void**)&wgpu_command_buffer_destroy, "wgpu_command_buffer_destroy");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_begin_compute_pass, "wgpu_command_encoder_begin_compute_pass");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_begin_render_pass, "wgpu_command_encoder_begin_render_pass");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_copy_buffer_to_buffer, "wgpu_command_encoder_copy_buffer_to_buffer");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_copy_buffer_to_texture, "wgpu_command_encoder_copy_buffer_to_texture");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_copy_texture_to_buffer, "wgpu_command_encoder_copy_texture_to_buffer");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_copy_texture_to_texture, "wgpu_command_encoder_copy_texture_to_texture");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_destroy, "wgpu_command_encoder_destroy");
    lib.bindSymbol(cast(void**)&wgpu_command_encoder_finish, "wgpu_command_encoder_finish");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_destroy, "wgpu_compute_pass_destroy");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_dispatch, "wgpu_compute_pass_dispatch");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_dispatch_indirect, "wgpu_compute_pass_dispatch_indirect");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_end_pass, "wgpu_compute_pass_end_pass");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_insert_debug_marker, "wgpu_compute_pass_insert_debug_marker");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_pop_debug_group, "wgpu_compute_pass_pop_debug_group");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_push_debug_group, "wgpu_compute_pass_push_debug_group");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_set_bind_group, "wgpu_compute_pass_set_bind_group");
    lib.bindSymbol(cast(void**)&wgpu_compute_pass_set_pipeline, "wgpu_compute_pass_set_pipeline");
    version(Android)
    {
        lib.bindSymbol(cast(void**)&wgpu_create_surface_from_android, "wgpu_create_surface_from_android");
    }
    version(OSX)
    {
        lib.bindSymbol(cast(void**)&wgpu_create_surface_from_metal_layer, "wgpu_create_surface_from_metal_layer");
    }
    version(linux)
    {
        lib.bindSymbol(cast(void**)&wgpu_create_surface_from_wayland, "wgpu_create_surface_from_wayland");
    }
    version(Windows)
    {
        lib.bindSymbol(cast(void**)&wgpu_create_surface_from_windows_hwnd, "wgpu_create_surface_from_windows_hwnd");
    }
    version(linux)
    {
        lib.bindSymbol(cast(void**)&wgpu_create_surface_from_xlib, "wgpu_create_surface_from_xlib");
    }
    lib.bindSymbol(cast(void**)&wgpu_device_create_bind_group, "wgpu_device_create_bind_group");
    lib.bindSymbol(cast(void**)&wgpu_device_create_bind_group_layout, "wgpu_device_create_bind_group_layout");
    lib.bindSymbol(cast(void**)&wgpu_device_create_buffer, "wgpu_device_create_buffer");
    lib.bindSymbol(cast(void**)&wgpu_device_create_command_encoder, "wgpu_device_create_command_encoder");
    lib.bindSymbol(cast(void**)&wgpu_device_create_compute_pipeline, "wgpu_device_create_compute_pipeline");
    lib.bindSymbol(cast(void**)&wgpu_device_create_pipeline_layout, "wgpu_device_create_pipeline_layout");
    lib.bindSymbol(cast(void**)&wgpu_device_create_render_pipeline, "wgpu_device_create_render_pipeline");
    lib.bindSymbol(cast(void**)&wgpu_device_create_sampler, "wgpu_device_create_sampler");
    lib.bindSymbol(cast(void**)&wgpu_device_create_shader_module, "wgpu_device_create_shader_module");
    lib.bindSymbol(cast(void**)&wgpu_device_create_swap_chain, "wgpu_device_create_swap_chain");
    lib.bindSymbol(cast(void**)&wgpu_device_create_texture, "wgpu_device_create_texture");
    lib.bindSymbol(cast(void**)&wgpu_device_destroy, "wgpu_device_destroy");
    lib.bindSymbol(cast(void**)&wgpu_device_get_limits, "wgpu_device_get_limits");
    lib.bindSymbol(cast(void**)&wgpu_device_get_default_queue, "wgpu_device_get_default_queue");
    lib.bindSymbol(cast(void**)&wgpu_device_poll, "wgpu_device_poll");
    lib.bindSymbol(cast(void**)&wgpu_queue_submit, "wgpu_queue_submit");
    lib.bindSymbol(cast(void**)&wgpu_queue_write_buffer, "wgpu_queue_write_buffer");
    lib.bindSymbol(cast(void**)&wgpu_queue_write_texture, "wgpu_queue_write_texture");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_draw, "wgpu_render_pass_draw");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_draw_indexed, "wgpu_render_pass_draw_indexed");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_draw_indexed_indirect, "wgpu_render_pass_draw_indexed_indirect");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_draw_indirect, "wgpu_render_pass_draw_indirect");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_end_pass, "wgpu_render_pass_end_pass");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_execute_bundles, "wgpu_render_pass_execute_bundles");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_insert_debug_marker, "wgpu_render_pass_insert_debug_marker");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_pop_debug_group, "wgpu_render_pass_pop_debug_group");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_push_debug_group, "wgpu_render_pass_push_debug_group");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_bind_group, "wgpu_render_pass_set_bind_group");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_blend_color, "wgpu_render_pass_set_blend_color");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_index_buffer, "wgpu_render_pass_set_index_buffer");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_pipeline, "wgpu_render_pass_set_pipeline");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_scissor_rect, "wgpu_render_pass_set_scissor_rect");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_stencil_reference, "wgpu_render_pass_set_stencil_reference");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_vertex_buffer, "wgpu_render_pass_set_vertex_buffer");
    lib.bindSymbol(cast(void**)&wgpu_render_pass_set_viewport, "wgpu_render_pass_set_viewport");
    lib.bindSymbol(cast(void**)&wgpu_render_pipeline_destroy, "wgpu_render_pipeline_destroy");
    lib.bindSymbol(cast(void**)&wgpu_request_adapter_async, "wgpu_request_adapter_async");
    lib.bindSymbol(cast(void**)&wgpu_sampler_destroy, "wgpu_sampler_destroy");
    lib.bindSymbol(cast(void**)&wgpu_set_log_callback, "wgpu_set_log_callback");
    lib.bindSymbol(cast(void**)&wgpu_set_log_level, "wgpu_set_log_level");
    lib.bindSymbol(cast(void**)&wgpu_shader_module_destroy, "wgpu_shader_module_destroy");
    lib.bindSymbol(cast(void**)&wgpu_swap_chain_get_next_texture, "wgpu_swap_chain_get_next_texture");
    lib.bindSymbol(cast(void**)&wgpu_swap_chain_present, "wgpu_swap_chain_present");
    lib.bindSymbol(cast(void**)&wgpu_texture_create_view, "wgpu_texture_create_view");
    lib.bindSymbol(cast(void**)&wgpu_texture_destroy, "wgpu_texture_destroy");
    lib.bindSymbol(cast(void**)&wgpu_texture_view_destroy, "wgpu_texture_view_destroy");

    loadedVersion = WGPUSupport.wgpu051;

    if (errorCount() != errCount)
        return WGPUSupport.badLibrary;

    return loadedVersion;
}
